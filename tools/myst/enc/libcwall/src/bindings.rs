/* automatically generated by rust-bindgen */

pub const _ERRNO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYS_POLL_H: u32 = 1;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRNORM: u32 = 256;
pub const POLLWRBAND: u32 = 512;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_STAT_H: u32 = 1;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _MKNOD_VER: u32 = 0;
pub const _SYSCALL_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const _ASM_X86_UNISTD_64_H: u32 = 1;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __GLIBC_LINUX_VERSION_CODE: u32 = 265728;
pub const SYS__sysctl: u32 = 156;
pub const SYS_accept: u32 = 43;
pub const SYS_accept4: u32 = 288;
pub const SYS_access: u32 = 21;
pub const SYS_acct: u32 = 163;
pub const SYS_add_key: u32 = 248;
pub const SYS_adjtimex: u32 = 159;
pub const SYS_afs_syscall: u32 = 183;
pub const SYS_alarm: u32 = 37;
pub const SYS_arch_prctl: u32 = 158;
pub const SYS_bind: u32 = 49;
pub const SYS_bpf: u32 = 321;
pub const SYS_brk: u32 = 12;
pub const SYS_capget: u32 = 125;
pub const SYS_capset: u32 = 126;
pub const SYS_chdir: u32 = 80;
pub const SYS_chmod: u32 = 90;
pub const SYS_chown: u32 = 92;
pub const SYS_chroot: u32 = 161;
pub const SYS_clock_adjtime: u32 = 305;
pub const SYS_clock_getres: u32 = 229;
pub const SYS_clock_gettime: u32 = 228;
pub const SYS_clock_nanosleep: u32 = 230;
pub const SYS_clock_settime: u32 = 227;
pub const SYS_clone: u32 = 56;
pub const SYS_close: u32 = 3;
pub const SYS_connect: u32 = 42;
pub const SYS_copy_file_range: u32 = 326;
pub const SYS_creat: u32 = 85;
pub const SYS_create_module: u32 = 174;
pub const SYS_delete_module: u32 = 176;
pub const SYS_dup: u32 = 32;
pub const SYS_dup2: u32 = 33;
pub const SYS_dup3: u32 = 292;
pub const SYS_epoll_create: u32 = 213;
pub const SYS_epoll_create1: u32 = 291;
pub const SYS_epoll_ctl: u32 = 233;
pub const SYS_epoll_ctl_old: u32 = 214;
pub const SYS_epoll_pwait: u32 = 281;
pub const SYS_epoll_wait: u32 = 232;
pub const SYS_epoll_wait_old: u32 = 215;
pub const SYS_eventfd: u32 = 284;
pub const SYS_eventfd2: u32 = 290;
pub const SYS_execve: u32 = 59;
pub const SYS_execveat: u32 = 322;
pub const SYS_exit: u32 = 60;
pub const SYS_exit_group: u32 = 231;
pub const SYS_faccessat: u32 = 269;
pub const SYS_fadvise64: u32 = 221;
pub const SYS_fallocate: u32 = 285;
pub const SYS_fanotify_init: u32 = 300;
pub const SYS_fanotify_mark: u32 = 301;
pub const SYS_fchdir: u32 = 81;
pub const SYS_fchmod: u32 = 91;
pub const SYS_fchmodat: u32 = 268;
pub const SYS_fchown: u32 = 93;
pub const SYS_fchownat: u32 = 260;
pub const SYS_fcntl: u32 = 72;
pub const SYS_fdatasync: u32 = 75;
pub const SYS_fgetxattr: u32 = 193;
pub const SYS_finit_module: u32 = 313;
pub const SYS_flistxattr: u32 = 196;
pub const SYS_flock: u32 = 73;
pub const SYS_fork: u32 = 57;
pub const SYS_fremovexattr: u32 = 199;
pub const SYS_fsetxattr: u32 = 190;
pub const SYS_fstat: u32 = 5;
pub const SYS_fstatfs: u32 = 138;
pub const SYS_fsync: u32 = 74;
pub const SYS_ftruncate: u32 = 77;
pub const SYS_futex: u32 = 202;
pub const SYS_futimesat: u32 = 261;
pub const SYS_get_kernel_syms: u32 = 177;
pub const SYS_get_mempolicy: u32 = 239;
pub const SYS_get_robust_list: u32 = 274;
pub const SYS_get_thread_area: u32 = 211;
pub const SYS_getcpu: u32 = 309;
pub const SYS_getcwd: u32 = 79;
pub const SYS_getdents: u32 = 78;
pub const SYS_getdents64: u32 = 217;
pub const SYS_getegid: u32 = 108;
pub const SYS_geteuid: u32 = 107;
pub const SYS_getgid: u32 = 104;
pub const SYS_getgroups: u32 = 115;
pub const SYS_getitimer: u32 = 36;
pub const SYS_getpeername: u32 = 52;
pub const SYS_getpgid: u32 = 121;
pub const SYS_getpgrp: u32 = 111;
pub const SYS_getpid: u32 = 39;
pub const SYS_getpmsg: u32 = 181;
pub const SYS_getppid: u32 = 110;
pub const SYS_getpriority: u32 = 140;
pub const SYS_getrandom: u32 = 318;
pub const SYS_getresgid: u32 = 120;
pub const SYS_getresuid: u32 = 118;
pub const SYS_getrlimit: u32 = 97;
pub const SYS_getrusage: u32 = 98;
pub const SYS_getsid: u32 = 124;
pub const SYS_getsockname: u32 = 51;
pub const SYS_getsockopt: u32 = 55;
pub const SYS_gettid: u32 = 186;
pub const SYS_gettimeofday: u32 = 96;
pub const SYS_getuid: u32 = 102;
pub const SYS_getxattr: u32 = 191;
pub const SYS_init_module: u32 = 175;
pub const SYS_inotify_add_watch: u32 = 254;
pub const SYS_inotify_init: u32 = 253;
pub const SYS_inotify_init1: u32 = 294;
pub const SYS_inotify_rm_watch: u32 = 255;
pub const SYS_io_cancel: u32 = 210;
pub const SYS_io_destroy: u32 = 207;
pub const SYS_io_getevents: u32 = 208;
pub const SYS_io_setup: u32 = 206;
pub const SYS_io_submit: u32 = 209;
pub const SYS_ioctl: u32 = 16;
pub const SYS_ioperm: u32 = 173;
pub const SYS_iopl: u32 = 172;
pub const SYS_ioprio_get: u32 = 252;
pub const SYS_ioprio_set: u32 = 251;
pub const SYS_kcmp: u32 = 312;
pub const SYS_kexec_file_load: u32 = 320;
pub const SYS_kexec_load: u32 = 246;
pub const SYS_keyctl: u32 = 250;
pub const SYS_kill: u32 = 62;
pub const SYS_lchown: u32 = 94;
pub const SYS_lgetxattr: u32 = 192;
pub const SYS_link: u32 = 86;
pub const SYS_linkat: u32 = 265;
pub const SYS_listen: u32 = 50;
pub const SYS_listxattr: u32 = 194;
pub const SYS_llistxattr: u32 = 195;
pub const SYS_lookup_dcookie: u32 = 212;
pub const SYS_lremovexattr: u32 = 198;
pub const SYS_lseek: u32 = 8;
pub const SYS_lsetxattr: u32 = 189;
pub const SYS_lstat: u32 = 6;
pub const SYS_madvise: u32 = 28;
pub const SYS_mbind: u32 = 237;
pub const SYS_membarrier: u32 = 324;
pub const SYS_memfd_create: u32 = 319;
pub const SYS_migrate_pages: u32 = 256;
pub const SYS_mincore: u32 = 27;
pub const SYS_mkdir: u32 = 83;
pub const SYS_mkdirat: u32 = 258;
pub const SYS_mknod: u32 = 133;
pub const SYS_mknodat: u32 = 259;
pub const SYS_mlock: u32 = 149;
pub const SYS_mlock2: u32 = 325;
pub const SYS_mlockall: u32 = 151;
pub const SYS_mmap: u32 = 9;
pub const SYS_modify_ldt: u32 = 154;
pub const SYS_mount: u32 = 165;
pub const SYS_move_pages: u32 = 279;
pub const SYS_mprotect: u32 = 10;
pub const SYS_mq_getsetattr: u32 = 245;
pub const SYS_mq_notify: u32 = 244;
pub const SYS_mq_open: u32 = 240;
pub const SYS_mq_timedreceive: u32 = 243;
pub const SYS_mq_timedsend: u32 = 242;
pub const SYS_mq_unlink: u32 = 241;
pub const SYS_mremap: u32 = 25;
pub const SYS_msgctl: u32 = 71;
pub const SYS_msgget: u32 = 68;
pub const SYS_msgrcv: u32 = 70;
pub const SYS_msgsnd: u32 = 69;
pub const SYS_msync: u32 = 26;
pub const SYS_munlock: u32 = 150;
pub const SYS_munlockall: u32 = 152;
pub const SYS_munmap: u32 = 11;
pub const SYS_name_to_handle_at: u32 = 303;
pub const SYS_nanosleep: u32 = 35;
pub const SYS_newfstatat: u32 = 262;
pub const SYS_nfsservctl: u32 = 180;
pub const SYS_open: u32 = 2;
pub const SYS_open_by_handle_at: u32 = 304;
pub const SYS_openat: u32 = 257;
pub const SYS_pause: u32 = 34;
pub const SYS_perf_event_open: u32 = 298;
pub const SYS_personality: u32 = 135;
pub const SYS_pipe: u32 = 22;
pub const SYS_pipe2: u32 = 293;
pub const SYS_pivot_root: u32 = 155;
pub const SYS_pkey_alloc: u32 = 330;
pub const SYS_pkey_free: u32 = 331;
pub const SYS_pkey_mprotect: u32 = 329;
pub const SYS_poll: u32 = 7;
pub const SYS_ppoll: u32 = 271;
pub const SYS_prctl: u32 = 157;
pub const SYS_pread64: u32 = 17;
pub const SYS_preadv: u32 = 295;
pub const SYS_preadv2: u32 = 327;
pub const SYS_prlimit64: u32 = 302;
pub const SYS_process_vm_readv: u32 = 310;
pub const SYS_process_vm_writev: u32 = 311;
pub const SYS_pselect6: u32 = 270;
pub const SYS_ptrace: u32 = 101;
pub const SYS_putpmsg: u32 = 182;
pub const SYS_pwrite64: u32 = 18;
pub const SYS_pwritev: u32 = 296;
pub const SYS_pwritev2: u32 = 328;
pub const SYS_query_module: u32 = 178;
pub const SYS_quotactl: u32 = 179;
pub const SYS_read: u32 = 0;
pub const SYS_readahead: u32 = 187;
pub const SYS_readlink: u32 = 89;
pub const SYS_readlinkat: u32 = 267;
pub const SYS_readv: u32 = 19;
pub const SYS_reboot: u32 = 169;
pub const SYS_recvfrom: u32 = 45;
pub const SYS_recvmmsg: u32 = 299;
pub const SYS_recvmsg: u32 = 47;
pub const SYS_remap_file_pages: u32 = 216;
pub const SYS_removexattr: u32 = 197;
pub const SYS_rename: u32 = 82;
pub const SYS_renameat: u32 = 264;
pub const SYS_renameat2: u32 = 316;
pub const SYS_request_key: u32 = 249;
pub const SYS_restart_syscall: u32 = 219;
pub const SYS_rmdir: u32 = 84;
pub const SYS_rt_sigaction: u32 = 13;
pub const SYS_rt_sigpending: u32 = 127;
pub const SYS_rt_sigprocmask: u32 = 14;
pub const SYS_rt_sigqueueinfo: u32 = 129;
pub const SYS_rt_sigreturn: u32 = 15;
pub const SYS_rt_sigsuspend: u32 = 130;
pub const SYS_rt_sigtimedwait: u32 = 128;
pub const SYS_rt_tgsigqueueinfo: u32 = 297;
pub const SYS_sched_get_priority_max: u32 = 146;
pub const SYS_sched_get_priority_min: u32 = 147;
pub const SYS_sched_getaffinity: u32 = 204;
pub const SYS_sched_getattr: u32 = 315;
pub const SYS_sched_getparam: u32 = 143;
pub const SYS_sched_getscheduler: u32 = 145;
pub const SYS_sched_rr_get_interval: u32 = 148;
pub const SYS_sched_setaffinity: u32 = 203;
pub const SYS_sched_setattr: u32 = 314;
pub const SYS_sched_setparam: u32 = 142;
pub const SYS_sched_setscheduler: u32 = 144;
pub const SYS_sched_yield: u32 = 24;
pub const SYS_seccomp: u32 = 317;
pub const SYS_security: u32 = 185;
pub const SYS_select: u32 = 23;
pub const SYS_semctl: u32 = 66;
pub const SYS_semget: u32 = 64;
pub const SYS_semop: u32 = 65;
pub const SYS_semtimedop: u32 = 220;
pub const SYS_sendfile: u32 = 40;
pub const SYS_sendmmsg: u32 = 307;
pub const SYS_sendmsg: u32 = 46;
pub const SYS_sendto: u32 = 44;
pub const SYS_set_mempolicy: u32 = 238;
pub const SYS_set_robust_list: u32 = 273;
pub const SYS_set_thread_area: u32 = 205;
pub const SYS_set_tid_address: u32 = 218;
pub const SYS_setdomainname: u32 = 171;
pub const SYS_setfsgid: u32 = 123;
pub const SYS_setfsuid: u32 = 122;
pub const SYS_setgid: u32 = 106;
pub const SYS_setgroups: u32 = 116;
pub const SYS_sethostname: u32 = 170;
pub const SYS_setitimer: u32 = 38;
pub const SYS_setns: u32 = 308;
pub const SYS_setpgid: u32 = 109;
pub const SYS_setpriority: u32 = 141;
pub const SYS_setregid: u32 = 114;
pub const SYS_setresgid: u32 = 119;
pub const SYS_setresuid: u32 = 117;
pub const SYS_setreuid: u32 = 113;
pub const SYS_setrlimit: u32 = 160;
pub const SYS_setsid: u32 = 112;
pub const SYS_setsockopt: u32 = 54;
pub const SYS_settimeofday: u32 = 164;
pub const SYS_setuid: u32 = 105;
pub const SYS_setxattr: u32 = 188;
pub const SYS_shmat: u32 = 30;
pub const SYS_shmctl: u32 = 31;
pub const SYS_shmdt: u32 = 67;
pub const SYS_shmget: u32 = 29;
pub const SYS_shutdown: u32 = 48;
pub const SYS_sigaltstack: u32 = 131;
pub const SYS_signalfd: u32 = 282;
pub const SYS_signalfd4: u32 = 289;
pub const SYS_socket: u32 = 41;
pub const SYS_socketpair: u32 = 53;
pub const SYS_splice: u32 = 275;
pub const SYS_stat: u32 = 4;
pub const SYS_statfs: u32 = 137;
pub const SYS_statx: u32 = 332;
pub const SYS_swapoff: u32 = 168;
pub const SYS_swapon: u32 = 167;
pub const SYS_symlink: u32 = 88;
pub const SYS_symlinkat: u32 = 266;
pub const SYS_sync: u32 = 162;
pub const SYS_sync_file_range: u32 = 277;
pub const SYS_syncfs: u32 = 306;
pub const SYS_sysfs: u32 = 139;
pub const SYS_sysinfo: u32 = 99;
pub const SYS_syslog: u32 = 103;
pub const SYS_tee: u32 = 276;
pub const SYS_tgkill: u32 = 234;
pub const SYS_time: u32 = 201;
pub const SYS_timer_create: u32 = 222;
pub const SYS_timer_delete: u32 = 226;
pub const SYS_timer_getoverrun: u32 = 225;
pub const SYS_timer_gettime: u32 = 224;
pub const SYS_timer_settime: u32 = 223;
pub const SYS_timerfd_create: u32 = 283;
pub const SYS_timerfd_gettime: u32 = 287;
pub const SYS_timerfd_settime: u32 = 286;
pub const SYS_times: u32 = 100;
pub const SYS_tkill: u32 = 200;
pub const SYS_truncate: u32 = 76;
pub const SYS_tuxcall: u32 = 184;
pub const SYS_umask: u32 = 95;
pub const SYS_umount2: u32 = 166;
pub const SYS_uname: u32 = 63;
pub const SYS_unlink: u32 = 87;
pub const SYS_unlinkat: u32 = 263;
pub const SYS_unshare: u32 = 272;
pub const SYS_uselib: u32 = 134;
pub const SYS_userfaultfd: u32 = 323;
pub const SYS_ustat: u32 = 136;
pub const SYS_utime: u32 = 132;
pub const SYS_utimensat: u32 = 280;
pub const SYS_utimes: u32 = 235;
pub const SYS_vfork: u32 = 58;
pub const SYS_vhangup: u32 = 153;
pub const SYS_vmsplice: u32 = 278;
pub const SYS_vserver: u32 = 236;
pub const SYS_wait4: u32 = 61;
pub const SYS_waitid: u32 = 247;
pub const SYS_write: u32 = 1;
pub const SYS_writev: u32 = 20;
pub const _SYS_TIME_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const OE_API_VERSION: u32 = 2;
pub const OE_ENUM_MAX: u32 = 4294967295;
pub const OE_PAGE_SIZE: u32 = 4096;
pub const OE_SCHAR_MIN: i32 = -128;
pub const OE_SCHAR_MAX: u32 = 127;
pub const OE_UCHAR_MAX: u32 = 255;
pub const OE_CHAR_MIN: i32 = -128;
pub const OE_CHAR_MAX: u32 = 127;
pub const OE_CHAR_BIT: u32 = 8;
pub const OE_SHRT_MIN: i32 = -32768;
pub const OE_SHRT_MAX: u32 = 32767;
pub const OE_USHRT_MAX: u32 = 65535;
pub const OE_INT_MIN: i32 = -2147483648;
pub const OE_INT_MAX: u32 = 2147483647;
pub const OE_UINT_MAX: u32 = 4294967295;
pub const OE_LONG_MAX: u64 = 9223372036854775807;
pub const OE_LONG_MIN: i64 = -9223372036854775808;
pub const OE_ULONG_MAX: i32 = -1;
pub const OE_LLONG_MAX: u64 = 9223372036854775807;
pub const OE_LLONG_MIN: i64 = -9223372036854775808;
pub const OE_ULLONG_MAX: i32 = -1;
pub const OE_INT8_MIN: i32 = -128;
pub const OE_INT8_MAX: u32 = 127;
pub const OE_UINT8_MAX: u32 = 255;
pub const OE_INT16_MIN: i32 = -32768;
pub const OE_INT16_MAX: u32 = 32767;
pub const OE_UINT16_MAX: u32 = 65535;
pub const OE_INT32_MIN: i32 = -2147483648;
pub const OE_INT32_MAX: u32 = 2147483647;
pub const OE_UINT32_MAX: u32 = 4294967295;
pub const OE_INT64_MIN: i64 = -9223372036854775808;
pub const OE_INT64_MAX: u64 = 9223372036854775807;
pub const OE_UINT64_MAX: i32 = -1;
pub const OE_SIZE_MAX: i32 = -1;
pub const OE_SSIZE_MAX: u64 = 9223372036854775807;
pub const OE_REPORT_FLAGS_REMOTE_ATTESTATION: u32 = 1;
pub const OE_REPORT_DATA_SIZE: u32 = 64;
pub const OE_MAX_REPORT_SIZE: u32 = 10240;
pub const OE_UNIQUE_ID_SIZE: u32 = 32;
pub const OE_SIGNER_ID_SIZE: u32 = 32;
pub const OE_PRODUCT_ID_SIZE: u32 = 16;
pub const OE_REPORT_ATTRIBUTES_DEBUG: u32 = 1;
pub const OE_REPORT_ATTRIBUTES_REMOTE: u32 = 2;
pub const OE_REPORT_ATTRIBUTES_RESERVED: i32 = -4;
pub const OE_EVIDENCE_ATTRIBUTES_SGX_DEBUG: u32 = 1;
pub const OE_EVIDENCE_ATTRIBUTES_SGX_REMOTE: u32 = 2;
pub const OE_EVIDENCE_ATTRIBUTES_RESERVED: i32 = -4;
pub const OE_UUID_SIZE: u32 = 16;
pub const OE_CLAIM_ID_VERSION: &'static [u8; 11usize] = b"id_version\0";
pub const OE_CLAIM_SECURITY_VERSION: &'static [u8; 17usize] = b"security_version\0";
pub const OE_CLAIM_ATTRIBUTES: &'static [u8; 11usize] = b"attributes\0";
pub const OE_CLAIM_UNIQUE_ID: &'static [u8; 10usize] = b"unique_id\0";
pub const OE_CLAIM_SIGNER_ID: &'static [u8; 10usize] = b"signer_id\0";
pub const OE_CLAIM_PRODUCT_ID: &'static [u8; 11usize] = b"product_id\0";
pub const OE_CLAIM_FORMAT_UUID: &'static [u8; 12usize] = b"format_uuid\0";
pub const OE_REQUIRED_CLAIMS_COUNT: u32 = 7;
pub const OE_CLAIM_VALIDITY_FROM: &'static [u8; 14usize] = b"validity_from\0";
pub const OE_CLAIM_VALIDITY_UNTIL: &'static [u8; 15usize] = b"validity_until\0";
pub const OE_OPTIONAL_CLAIMS_COUNT: u32 = 2;
pub const OE_CLAIM_CUSTOM_CLAIMS_BUFFER: &'static [u8; 21usize] = b"custom_claims_buffer\0";
pub const OE_EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const OE_EXCEPTION_CONTINUE_EXECUTION: u32 = 4294967295;
pub const OE_EXCEPTION_DIVIDE_BY_ZERO: u32 = 0;
pub const OE_EXCEPTION_BREAKPOINT: u32 = 1;
pub const OE_EXCEPTION_BOUND_OUT_OF_RANGE: u32 = 2;
pub const OE_EXCEPTION_ILLEGAL_INSTRUCTION: u32 = 3;
pub const OE_EXCEPTION_ACCESS_VIOLATION: u32 = 4;
pub const OE_EXCEPTION_PAGE_FAULT: u32 = 5;
pub const OE_EXCEPTION_X87_FLOAT_POINT: u32 = 6;
pub const OE_EXCEPTION_MISALIGNMENT: u32 = 7;
pub const OE_EXCEPTION_SIMD_FLOAT_POINT: u32 = 8;
pub const OE_EXCEPTION_UNKNOWN: u32 = 4294967295;
pub const OE_EXCEPTION_FLAGS_HARDWARE: u32 = 1;
pub const OE_EXCEPTION_FLAGS_SOFTWARE: u32 = 2;
pub const OE_HOST_FILE_SYSTEM: &'static [u8; 20usize] = b"oe_host_file_system\0";
pub const OE_INFO_SECTION_NAME: &'static [u8; 8usize] = b".oeinfo\0";
pub const OE_SGX_MAX_TCS: u32 = 32;
pub const OE_SGX_FLAGS_DEBUG: u32 = 2;
pub const OE_SGX_FLAGS_MODE64BIT: u32 = 4;
pub const OE_SGX_SIGSTRUCT_SIZE: u32 = 1808;
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(
        arg1: *mut _IO_FILE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: _bindgen_ty_1 = 0;
pub const DT_FIFO: _bindgen_ty_1 = 1;
pub const DT_CHR: _bindgen_ty_1 = 2;
pub const DT_DIR: _bindgen_ty_1 = 4;
pub const DT_BLK: _bindgen_ty_1 = 6;
pub const DT_REG: _bindgen_ty_1 = 8;
pub const DT_LNK: _bindgen_ty_1 = 10;
pub const DT_SOCK: _bindgen_ty_1 = 12;
pub const DT_WHT: _bindgen_ty_1 = 14;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
pub type mode_t = __mode_t;
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
pub type nfds_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    pub fn poll(
        __fds: *mut pollfd,
        __nfds: nfds_t,
        __timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type ino_t = __ino_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(
        __ver: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(
        __ver: ::std::os::raw::c_int,
        __fildes: ::std::os::raw::c_int,
        __filename: *const ::std::os::raw::c_char,
        __stat_buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(
        __ver: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(
        __ver: ::std::os::raw::c_int,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: *mut __dev_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _myst_path {
    pub buf: [::std::os::raw::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout__myst_path() {
    assert_eq!(
        ::std::mem::size_of::<_myst_path>(),
        4096usize,
        concat!("Size of: ", stringify!(_myst_path))
    );
    assert_eq!(
        ::std::mem::align_of::<_myst_path>(),
        1usize,
        concat!("Alignment of ", stringify!(_myst_path))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_myst_path>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_myst_path),
            "::",
            stringify!(buf)
        )
    );
}
pub type myst_path_t = _myst_path;
pub const SYS_myst_trace: _bindgen_ty_2 = 1001;
pub const SYS_myst_trace_ptr: _bindgen_ty_2 = 1002;
pub const SYS_myst_dump_stack: _bindgen_ty_2 = 1003;
pub const SYS_myst_dump_ehdr: _bindgen_ty_2 = 1004;
pub const SYS_myst_dump_argv: _bindgen_ty_2 = 1005;
pub const SYS_myst_add_symbol_file: _bindgen_ty_2 = 1006;
pub const SYS_myst_load_symbols: _bindgen_ty_2 = 1007;
pub const SYS_myst_unload_symbols: _bindgen_ty_2 = 1008;
pub const SYS_myst_gen_creds: _bindgen_ty_2 = 1009;
pub const SYS_myst_free_creds: _bindgen_ty_2 = 1010;
pub const SYS_myst_verify_cert: _bindgen_ty_2 = 1011;
pub const SYS_myst_clone: _bindgen_ty_2 = 1012;
pub const SYS_myst_gcov_init: _bindgen_ty_2 = 1013;
pub const SYS_myst_max_threads: _bindgen_ty_2 = 1014;
pub const SYS_myst_poll_wake: _bindgen_ty_2 = 1015;
pub const SYS_myst_run_itimer: _bindgen_ty_2 = 1016;
pub const SYS_myst_oe_get_report_v2: _bindgen_ty_2 = 1017;
pub const SYS_myst_oe_free_report: _bindgen_ty_2 = 1018;
pub const SYS_myst_oe_get_target_info_v2: _bindgen_ty_2 = 1019;
pub const SYS_myst_oe_free_target_info: _bindgen_ty_2 = 1020;
pub const SYS_myst_oe_parse_report: _bindgen_ty_2 = 1021;
pub const SYS_myst_oe_verify_report: _bindgen_ty_2 = 1022;
pub const SYS_myst_oe_get_seal_key_by_policy_v2: _bindgen_ty_2 = 1023;
pub const SYS_myst_oe_get_public_key_by_policy: _bindgen_ty_2 = 1024;
pub const SYS_myst_oe_get_public_key: _bindgen_ty_2 = 1025;
pub const SYS_myst_oe_get_private_key_by_policy: _bindgen_ty_2 = 1026;
pub const SYS_myst_oe_get_private_key: _bindgen_ty_2 = 1027;
pub const SYS_myst_oe_free_key: _bindgen_ty_2 = 1028;
pub const SYS_myst_oe_get_seal_key_v2: _bindgen_ty_2 = 1029;
pub const SYS_myst_oe_free_seal_key: _bindgen_ty_2 = 1030;
pub const SYS_myst_oe_generate_attestation_certificate: _bindgen_ty_2 = 1031;
pub const SYS_myst_oe_free_attestation_certificate: _bindgen_ty_2 = 1032;
pub const SYS_myst_oe_verify_attestation_certificate: _bindgen_ty_2 = 1033;
pub const SYS_myst_oe_result_str: _bindgen_ty_2 = 1034;
pub type _bindgen_ty_2 = u32;
extern "C" {
    pub fn myst_syscall(
        n: ::std::os::raw::c_long,
        params: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn syscall_str(n: ::std::os::raw::c_long) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn myst_set_rootfs(path: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn myst_syscall_ret(r: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_creat(
        pathname: *const ::std::os::raw::c_char,
        mode: mode_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_openat(
        dirfd: ::std::os::raw::c_int,
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: mode_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_lseek(
        fd: ::std::os::raw::c_int,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_read(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_pread(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
        offset: off_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_pwrite(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: size_t,
        offset: off_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_readv(
        fd: ::std::os::raw::c_int,
        iov: *const iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_writev(
        fd: ::std::os::raw::c_int,
        iov: *const iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_stat(
        pathname: *const ::std::os::raw::c_char,
        statbuf: *mut stat,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_lstat(
        pathname: *const ::std::os::raw::c_char,
        statbuf: *mut stat,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_fstat(
        fd: ::std::os::raw::c_int,
        statbuf: *mut stat,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_mkdir(
        pathname: *const ::std::os::raw::c_char,
        mode: mode_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_getdents64(
        fd: ::std::os::raw::c_int,
        dirp: *mut dirent,
        count: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_rmdir(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_link(
        oldpath: *const ::std::os::raw::c_char,
        newpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_unlink(pathname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_access(
        pathname: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_rename(
        oldpath: *const ::std::os::raw::c_char,
        newpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_truncate(
        path: *const ::std::os::raw::c_char,
        length: off_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_ftruncate(
        fd: ::std::os::raw::c_int,
        length: off_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_readlink(
        pathname: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        bufsiz: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_symlink(
        target: *const ::std::os::raw::c_char,
        linkpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_chdir(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_getcwd(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_fcntl(
        fd: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_add_symbol_file(
        path: *const ::std::os::raw::c_char,
        text: *const ::std::os::raw::c_void,
        text_size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_load_symbols() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_unload_symbols() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_clock_getres(
        clk_id: clockid_t,
        res: *mut timespec,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_clock_gettime(
        clk_id: clockid_t,
        tp: *mut timespec,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_clock_settime(
        clk_id: clockid_t,
        tp: *mut timespec,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_gettimeofday(tv: *mut timeval, tz: *mut timezone)
        -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_time(tloc: *mut time_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_clone(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        child_stack: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
        ptid: *mut pid_t,
        newtls: *mut ::std::os::raw::c_void,
        ctid: *mut pid_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_futex(
        uaddr: *mut ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_long,
        uaddr2: *mut ::std::os::raw::c_int,
        val3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_getrandom(
        buf: *mut ::std::os::raw::c_void,
        buflen: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    _unused: [u8; 0],
}
extern "C" {
    pub fn myst_syscall_wait4(
        pid: pid_t,
        wstatus: *mut ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
        rusage: *mut rusage,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_poll(
        fds: *mut pollfd,
        nfds: nfds_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_select(
        nfds: ::std::os::raw::c_int,
        readfds: *mut fd_set,
        writefds: *mut fd_set,
        exceptfds: *mut fd_set,
        timeout: *mut timeval,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_nanosleep(
        req: *const timespec,
        rem: *mut timespec,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_exit_group(status: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_tgkill(
        tgid: ::std::os::raw::c_int,
        tid: ::std::os::raw::c_int,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_mount(
        source: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        filesystemtype: *const ::std::os::raw::c_char,
        mountflags: ::std::os::raw::c_ulong,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_umount2(
        target: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_kill(
        pid: ::std::os::raw::c_int,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_sethostname(
        hostname: *const ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_sendfile(
        out_fd: ::std::os::raw::c_int,
        in_fd: ::std::os::raw::c_int,
        offset: *mut off_t,
        count: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_umask(mask: mode_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_run_itimer() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_setitimer(
        which: ::std::os::raw::c_int,
        new_value: *const itimerval,
        old_value: *mut itimerval,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn myst_syscall_getitimer(
        which: ::std::os::raw::c_int,
        curr_value: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn myst_syscall_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
#[doc = " OE_ENCLAVE_TYPE_AUTO will pick the type"]
#[doc = " based on the target platform that is being built, such that x64 binaries"]
#[doc = " will use SGX."]
pub const _oe_enclave_type_OE_ENCLAVE_TYPE_AUTO: _oe_enclave_type = 1;
#[doc = " OE_ENCLAVE_TYPE_SGX will force the platform to use SGX, but any platform"]
#[doc = " other than x64 will not support this and will generate errors."]
pub const _oe_enclave_type_OE_ENCLAVE_TYPE_SGX: _oe_enclave_type = 2;
#[doc = " OE_ENCLAVE_TYPE_OPTEE will force the platform to use OP-TEE, but any"]
#[doc = " platform other than one that implements ARM TrustZone with OP-TEE as its"]
#[doc = " secure kernel will not support this and will generate errors."]
pub const _oe_enclave_type_OE_ENCLAVE_TYPE_OPTEE: _oe_enclave_type = 3;
#[doc = " Unused"]
pub const _oe_enclave_type___OE_ENCLAVE_TYPE_MAX: _oe_enclave_type = 4294967295;
#[doc = " This enumeration defines values for the type parameter"]
#[doc = " passed to **oe_create_enclave()**."]
pub type _oe_enclave_type = u32;
pub use self::_oe_enclave_type as oe_enclave_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_enclave {
    _unused: [u8; 0],
}
#[doc = " This is an opaque handle to an enclave returned by oe_create_enclave()."]
#[doc = " This definition is shared by the enclave and the host."]
pub type oe_enclave_t = _oe_enclave;
#[doc = " Key is derived from a measurement of the enclave. Under this policy,"]
#[doc = " the sealed secret can only be unsealed by an instance of the exact"]
#[doc = " enclave code that sealed it."]
pub const _oe_seal_policy_OE_SEAL_POLICY_UNIQUE: _oe_seal_policy = 1;
#[doc = " Key is derived from the signer of the enclave. Under this policy,"]
#[doc = " the sealed secret can be unsealed by any enclave signed by the same"]
#[doc = " signer as that of the sealing enclave."]
pub const _oe_seal_policy_OE_SEAL_POLICY_PRODUCT: _oe_seal_policy = 2;
#[doc = " Unused."]
pub const _oe_seal_policy__OE_SEAL_POLICY_MAX: _oe_seal_policy = 4294967295;
#[doc = " This enumeration type defines the policy used to derive a seal key."]
#[doc = " This definition is shared by the enclave and the host."]
pub type _oe_seal_policy = u32;
pub use self::_oe_seal_policy as oe_seal_policy_t;
#[doc = " This struct defines a datetime up to 1 second precision."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_datetime {
    pub year: u32,
    pub month: u32,
    pub day: u32,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
}
#[test]
fn bindgen_test_layout__oe_datetime() {
    assert_eq!(
        ::std::mem::size_of::<_oe_datetime>(),
        24usize,
        concat!("Size of: ", stringify!(_oe_datetime))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_datetime>(),
        4usize,
        concat!("Alignment of ", stringify!(_oe_datetime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).month as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).hours as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).minutes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_datetime>())).seconds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_datetime),
            "::",
            stringify!(seconds)
        )
    );
}
pub type oe_datetime_t = _oe_datetime;
#[doc = " The function was successful."]
pub const _oe_result_OE_OK: _oe_result = 0;
#[doc = " The function failed (without a more specific error code)."]
pub const _oe_result_OE_FAILURE: _oe_result = 1;
#[doc = " One or more output buffer function parameters is too small."]
pub const _oe_result_OE_BUFFER_TOO_SMALL: _oe_result = 2;
#[doc = " One or more input function parameters is invalid. Either the value of"]
#[doc = " an input parameter is invalid or a required input parameter pointer"]
#[doc = " is null."]
pub const _oe_result_OE_INVALID_PARAMETER: _oe_result = 3;
#[doc = " The host attempted to perform a reentrant **ECALL**. This occurs when an"]
#[doc = " **OCALL** function attempts to perform an **ECALL**."]
pub const _oe_result_OE_REENTRANT_ECALL: _oe_result = 4;
#[doc = " The function is out of memory. This usually occurs when **malloc** or"]
#[doc = " a related function returns null."]
pub const _oe_result_OE_OUT_OF_MEMORY: _oe_result = 5;
#[doc = " The function is unable to bind the current host thread to an enclave"]
#[doc = " thread. This occurs when the host performs an **ECALL** while all enclave"]
#[doc = " threads are in use."]
pub const _oe_result_OE_OUT_OF_THREADS: _oe_result = 6;
#[doc = " The function encountered an unexpected failure."]
pub const _oe_result_OE_UNEXPECTED: _oe_result = 7;
#[doc = " A cryptographic verification failed. Examples include:"]
#[doc = "     - enclave quote verification"]
#[doc = "     - public key signature verification"]
#[doc = "     - certificate chain verification"]
pub const _oe_result_OE_VERIFY_FAILED: _oe_result = 8;
#[doc = " The function failed to find a resource. Examples of resources include"]
#[doc = " files, directories, and functions (ECALL/OCALL), container elements."]
pub const _oe_result_OE_NOT_FOUND: _oe_result = 9;
#[doc = " The function encountered an overflow in an integer operation, which"]
#[doc = " can occur in arithmetic operations and cast operations."]
pub const _oe_result_OE_INTEGER_OVERFLOW: _oe_result = 10;
#[doc = " The certificate does not contain a public key."]
pub const _oe_result_OE_PUBLIC_KEY_NOT_FOUND: _oe_result = 11;
#[doc = " An integer index is outside the expected range. For example, an array"]
#[doc = " index is greater than or equal to the array size."]
pub const _oe_result_OE_OUT_OF_BOUNDS: _oe_result = 12;
#[doc = " The function prevented an attempt to perform an overlapped copy, where"]
#[doc = " the source and destination buffers are overlapping."]
pub const _oe_result_OE_OVERLAPPED_COPY: _oe_result = 13;
#[doc = " The function detected a constraint failure. A constraint restricts the"]
#[doc = " the value of a field, parameter, or variable. For example, the value of"]
#[doc = " **day_of_the_week** must be between 1 and 7 inclusive."]
pub const _oe_result_OE_CONSTRAINT_FAILED: _oe_result = 14;
#[doc = " An **IOCTL** operation failed. Open Enclave uses **IOCTL** operations to"]
#[doc = " communicate with the Intel SGX driver."]
pub const _oe_result_OE_IOCTL_FAILED: _oe_result = 15;
#[doc = " The given operation is unsupported, usually by a particular platform"]
#[doc = " or environment."]
pub const _oe_result_OE_UNSUPPORTED: _oe_result = 16;
#[doc = " The function failed to read data from a device (such as a socket, or"]
#[doc = " file)."]
pub const _oe_result_OE_READ_FAILED: _oe_result = 17;
#[doc = " A software service is unavailable (such as the AESM service)."]
pub const _oe_result_OE_SERVICE_UNAVAILABLE: _oe_result = 18;
#[doc = " The operation cannot be completed because the enclave is aborting."]
pub const _oe_result_OE_ENCLAVE_ABORTING: _oe_result = 19;
#[doc = " The operation cannot be completed because the enclave has already"]
#[doc = " aborted."]
pub const _oe_result_OE_ENCLAVE_ABORTED: _oe_result = 20;
#[doc = " The underlying platform or hardware returned an error. For example,"]
#[doc = " an SGX user-mode instruction failed."]
pub const _oe_result_OE_PLATFORM_ERROR: _oe_result = 21;
#[doc = " The given **CPUSVN** value is invalid. An SGX user-mode instruction may"]
#[doc = " return this error."]
pub const _oe_result_OE_INVALID_CPUSVN: _oe_result = 22;
#[doc = " The given **ISVSNV** value is invalid. An SGX user-mode instruction may"]
#[doc = " return this error."]
pub const _oe_result_OE_INVALID_ISVSVN: _oe_result = 23;
#[doc = " The given **key name** is invalid. An SGX user-mode instruction may"]
#[doc = " return this error."]
pub const _oe_result_OE_INVALID_KEYNAME: _oe_result = 24;
#[doc = " Attempted to create a debug enclave with an enclave image that does"]
#[doc = " not allow it."]
pub const _oe_result_OE_DEBUG_DOWNGRADE: _oe_result = 25;
#[doc = " Failed to parse an enclave report."]
pub const _oe_result_OE_REPORT_PARSE_ERROR: _oe_result = 26;
#[doc = " The certificate chain is not available or missing."]
pub const _oe_result_OE_MISSING_CERTIFICATE_CHAIN: _oe_result = 27;
#[doc = " An operation cannot be performed beause the resource is busy. For"]
#[doc = " example, a non-recursive mutex cannot be locked because it is already"]
#[doc = " locked."]
pub const _oe_result_OE_BUSY: _oe_result = 28;
#[doc = " An operation cannot be performed because the requestor is not the"]
#[doc = " owner of the resource. For example, a thread cannot lock a mutex"]
#[doc = " because it is not the thread that acquired the mutex."]
pub const _oe_result_OE_NOT_OWNER: _oe_result = 29;
#[doc = " The certificate does not contain the expected SGX extensions."]
pub const _oe_result_OE_INVALID_SGX_CERTIFICATE_EXTENSIONS: _oe_result = 30;
#[doc = " A memory leak was detected during enclave termination."]
pub const _oe_result_OE_MEMORY_LEAK: _oe_result = 31;
#[doc = " The data is improperly aligned for the given operation. This may occur"]
#[doc = " when an output buffer parameter is not suitably aligned for the data"]
#[doc = " it will receive."]
pub const _oe_result_OE_BAD_ALIGNMENT: _oe_result = 32;
#[doc = " Failed to parse the trusted computing base (TCB) revocation data"]
#[doc = " or the QE Identity data for the enclave."]
pub const _oe_result_OE_JSON_INFO_PARSE_ERROR: _oe_result = 33;
#[doc = " The level of the trusted computing base (TCB) is not up to date for"]
#[doc = " report verification."]
pub const _oe_result_OE_TCB_LEVEL_INVALID: _oe_result = 34;
#[doc = " Failed to load the quote provider library used for quote generation"]
#[doc = " and attestation."]
pub const _oe_result_OE_QUOTE_PROVIDER_LOAD_ERROR: _oe_result = 35;
#[doc = " A call to the quote provider failed."]
pub const _oe_result_OE_QUOTE_PROVIDER_CALL_ERROR: _oe_result = 36;
#[doc = " The certificate revocation data for attesting the trusted computing"]
#[doc = " base (TCB) is invalid for this enclave."]
pub const _oe_result_OE_INVALID_REVOCATION_INFO: _oe_result = 37;
#[doc = " The given UTC date-time string or structure is invalid. This occurs"]
#[doc = " when (1) an element is out of range (year, month, day, hours, minutes,"]
#[doc = " seconds), or (2) the UTC date-time string is malformed."]
pub const _oe_result_OE_INVALID_UTC_DATE_TIME: _oe_result = 38;
#[doc = " The QE identity data is invalid."]
pub const _oe_result_OE_INVALID_QE_IDENTITY_INFO: _oe_result = 39;
#[doc = " The quote verification collateral is invalid."]
pub const _oe_result_OE_INVALID_ENDORSEMENT: _oe_result = 40;
#[doc = " The enclave image contains unsupported constructs."]
pub const _oe_result_OE_UNSUPPORTED_ENCLAVE_IMAGE: _oe_result = 41;
#[doc = " The CRL for a certificate has expired."]
pub const _oe_result_OE_VERIFY_CRL_EXPIRED: _oe_result = 42;
#[doc = " The CRL for a certificate could not be found."]
pub const _oe_result_OE_VERIFY_CRL_MISSING: _oe_result = 43;
#[doc = " The certificate or signature has been revoked."]
pub const _oe_result_OE_VERIFY_REVOKED: _oe_result = 44;
#[doc = " Could not find a valid validity period."]
pub const _oe_result_OE_VERIFY_FAILED_TO_FIND_VALIDITY_PERIOD: _oe_result = 45;
#[doc = " An underlying crypto provider returned an error."]
pub const _oe_result_OE_CRYPTO_ERROR: _oe_result = 46;
#[doc = " OE report size does not match the expected size."]
pub const _oe_result_OE_INCORRECT_REPORT_SIZE: _oe_result = 47;
#[doc = " Quote verification error."]
pub const _oe_result_OE_QUOTE_VERIFICATION_ERROR: _oe_result = 48;
#[doc = " Quote enclave identity verification failed."]
pub const _oe_result_OE_QUOTE_ENCLAVE_IDENTITY_VERIFICATION_FAILED: _oe_result = 49;
#[doc = " Unique id of the quoting enclave does not match expected value."]
pub const _oe_result_OE_QUOTE_ENCLAVE_IDENTITY_UNIQUEID_MISMATCH: _oe_result = 50;
#[doc = " Product id of the quoting enclave does not match expected value."]
pub const _oe_result_QE_QUOTE_ENCLAVE_IDENTITY_PRODUCTID_MISMATCH: _oe_result = 51;
#[doc = " AES CMAC of the report does not match the expected value."]
pub const _oe_result_OE_VERIFY_FAILED_AES_CMAC_MISMATCH: _oe_result = 52;
#[doc = " Failed to post a switchless call to host workers"]
pub const _oe_result_OE_CONTEXT_SWITCHLESS_OCALL_MISSED: _oe_result = 53;
#[doc = " Thread creation failed."]
pub const _oe_result_OE_THREAD_CREATE_ERROR: _oe_result = 54;
#[doc = " Thread join failed."]
pub const _oe_result_OE_THREAD_JOIN_ERROR: _oe_result = 55;
#[doc = " The desired resource already exists."]
pub const _oe_result_OE_ALREADY_EXISTS: _oe_result = 56;
#[doc = " The desired resource has already been initialized."]
pub const _oe_result_OE_ALREADY_INITIALIZED: _oe_result = 57;
#[doc = " The hash of claims section in the quote does not match the hash value"]
#[doc = " held in the report_data field. This occurs when claims are tampered."]
pub const _oe_result_OE_QUOTE_HASH_MISMATCH: _oe_result = 58;
#[doc = " The signing key provided cannot be used for SGX signing. This is"]
#[doc = " usually because the key is not an 3084-bit RSA key with exponent 3."]
pub const _oe_result_OE_INVALID_SGX_SIGNING_KEY: _oe_result = 59;
#[doc = " The binary image being loaded into the enclave could not be parsed."]
pub const _oe_result_OE_INVALID_IMAGE: _oe_result = 60;
#[doc = " Failed to load the quote library used for quote generation and"]
#[doc = " attestation."]
pub const _oe_result_OE_QUOTE_LIBRARY_LOAD_ERROR: _oe_result = 61;
#[doc = " Failed to load the quote library used for quote generation and"]
#[doc = " attestation."]
pub const _oe_result___OE_RESULT_MAX: _oe_result = 4294967295;
#[doc = " This enumeration type defines return codes for Open Enclave functions."]
#[doc = " These functions return **OE_OK** upon success and one of the other"]
#[doc = " enumeration values on failure."]
pub type _oe_result = u32;
pub use self::_oe_result as oe_result_t;
extern "C" {
    #[doc = " Retrieve a string for a result code."]
    #[doc = ""]
    #[doc = " This function retrieves a string description for the given **result**"]
    #[doc = " parameter."]
    #[doc = ""]
    #[doc = " @param[in] result Retrieve string description for this result code."]
    #[doc = ""]
    #[doc = " @returns Returns a pointer to a static string description."]
    #[doc = ""]
    pub fn oe_result_str(result: oe_result_t) -> *const ::std::os::raw::c_char;
}
pub const oe_asymmetric_key_type_t_OE_ASYMMETRIC_KEY_EC_SECP256P1: oe_asymmetric_key_type_t = 1;
pub const oe_asymmetric_key_type_t__OE_ASYMMETRIC_KEY_TYPE_MAX: oe_asymmetric_key_type_t =
    4294967295;
pub type oe_asymmetric_key_type_t = u32;
pub const oe_asymmetric_key_format_t_OE_ASYMMETRIC_KEY_PEM: oe_asymmetric_key_format_t = 1;
pub const oe_asymmetric_key_format_t__OE_ASYMMETRIC_KEY_FORMAT_MAX: oe_asymmetric_key_format_t =
    4294967295;
pub type oe_asymmetric_key_format_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oe_asymmetric_key_params_t {
    pub type_: oe_asymmetric_key_type_t,
    pub format: oe_asymmetric_key_format_t,
    pub user_data: *mut ::std::os::raw::c_void,
    pub user_data_size: size_t,
}
#[test]
fn bindgen_test_layout_oe_asymmetric_key_params_t() {
    assert_eq!(
        ::std::mem::size_of::<oe_asymmetric_key_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(oe_asymmetric_key_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<oe_asymmetric_key_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(oe_asymmetric_key_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_asymmetric_key_params_t>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_asymmetric_key_params_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_asymmetric_key_params_t>())).format as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_asymmetric_key_params_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_asymmetric_key_params_t>())).user_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_asymmetric_key_params_t),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_asymmetric_key_params_t>())).user_data_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_asymmetric_key_params_t),
            "::",
            stringify!(user_data_size)
        )
    );
}
#[doc = " Structure to represent the identity of an enclave."]
#[doc = " This structure is expected to change in future."]
#[doc = " Newer fields are always added at the end and fields are never removed."]
#[doc = " Before accessing a field, the enclave must first check that the field is"]
#[doc = " valid using the id_version and the table below:"]
#[doc = ""]
#[doc = " id_version | Supported fields"]
#[doc = " -----------| --------------------------------------------------------------"]
#[doc = "     0      | security_version, attributes, unique_id, signer_id, product_id"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_identity {
    #[doc = " Version of the oe_identity_t structure"]
    pub id_version: u32,
    #[doc = " Security version of the enclave. For SGX enclaves, this is the"]
    #[doc = "  ISVN value"]
    pub security_version: u32,
    #[doc = " Values of the attributes flags for the enclave -"]
    #[doc = "  OE_REPORT_ATTRIBUTES_DEBUG: The report is for a debug enclave."]
    #[doc = "  OE_REPORT_ATTRIBUTES_REMOTE: The report can be used for remote"]
    #[doc = "  attestation"]
    pub attributes: u64,
    #[doc = " The unique ID for the enclave."]
    #[doc = " For SGX enclaves, this is the MRENCLAVE value"]
    pub unique_id: [u8; 32usize],
    #[doc = " The signer ID for the enclave."]
    #[doc = " For SGX enclaves, this is the MRSIGNER value"]
    pub signer_id: [u8; 32usize],
    #[doc = " The Product ID for the enclave."]
    #[doc = " For SGX enclaves, this is the ISVPRODID value."]
    pub product_id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__oe_identity() {
    assert_eq!(
        ::std::mem::size_of::<_oe_identity>(),
        96usize,
        concat!("Size of: ", stringify!(_oe_identity))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_identity>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_identity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).id_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(id_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).security_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(security_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).unique_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(unique_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).signer_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(signer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_identity>())).product_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_identity),
            "::",
            stringify!(product_id)
        )
    );
}
pub type oe_identity_t = _oe_identity;
#[doc = " Structure to hold the parsed form of a report."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_report {
    #[doc = " Size of the oe_report_t structure."]
    pub size: size_t,
    #[doc = " The enclave type. Currently always OE_ENCLAVE_TYPE_SGX."]
    pub type_: oe_enclave_type_t,
    #[doc = " Size of report_data"]
    pub report_data_size: size_t,
    #[doc = " Size of enclave_report"]
    pub enclave_report_size: size_t,
    #[doc = " Pointer to report data field within the report byte-stream supplied to"]
    #[doc = " oe_parse_report"]
    pub report_data: *mut u8,
    #[doc = " Pointer to report body field within the report byte-stream supplied to"]
    #[doc = " oe_parse_report."]
    pub enclave_report: *mut u8,
    #[doc = " Contains the IDs and attributes that are part of oe_identity_t"]
    pub identity: oe_identity_t,
}
#[test]
fn bindgen_test_layout__oe_report() {
    assert_eq!(
        ::std::mem::size_of::<_oe_report>(),
        144usize,
        concat!("Size of: ", stringify!(_oe_report))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_report>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_report))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).report_data_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(report_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).enclave_report_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(enclave_report_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).report_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(report_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).enclave_report as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(enclave_report)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_report>())).identity as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_report),
            "::",
            stringify!(identity)
        )
    );
}
pub type oe_report_t = _oe_report;
#[doc = " Struct containing the definition for an UUID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_uuid_t {
    pub b: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__oe_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_oe_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_oe_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_oe_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_uuid_t>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_uuid_t),
            "::",
            stringify!(b)
        )
    );
}
pub type oe_uuid_t = _oe_uuid_t;
#[doc = " Claims struct used for claims parameters for the attestation plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_claim {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut u8,
    pub value_size: size_t,
}
#[test]
fn bindgen_test_layout__oe_claim() {
    assert_eq!(
        ::std::mem::size_of::<_oe_claim>(),
        24usize,
        concat!("Size of: ", stringify!(_oe_claim))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_claim>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_claim))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_claim>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_claim),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_claim>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_claim),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_claim>())).value_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_claim),
            "::",
            stringify!(value_size)
        )
    );
}
pub type oe_claim_t = _oe_claim;
extern "C" {
    pub static mut OE_REQUIRED_CLAIMS: [*const ::std::os::raw::c_char; 7usize];
}
extern "C" {
    pub static mut OE_OPTIONAL_CLAIMS: [*const ::std::os::raw::c_char; 2usize];
}
#[doc = " Enforces that time fields in the endorsements will be checked"]
#[doc = " with the given time rather than the endorsement creation time."]
#[doc = ""]
#[doc = " The policy will be in the form of `oe_datetime_t`."]
pub const _oe_policy_type_OE_POLICY_ENDORSEMENTS_TIME: _oe_policy_type = 1;
#[doc = " Supported policies for validation by the verifier attestation plugin."]
#[doc = " Only time is supported for now."]
pub type _oe_policy_type = u32;
pub use self::_oe_policy_type as oe_policy_type_t;
#[doc = " Generic struct for defining policy for the attestation plugins."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_policy {
    pub type_: oe_policy_type_t,
    pub policy: *mut ::std::os::raw::c_void,
    pub policy_size: size_t,
}
#[test]
fn bindgen_test_layout__oe_policy() {
    assert_eq!(
        ::std::mem::size_of::<_oe_policy>(),
        24usize,
        concat!("Size of: ", stringify!(_oe_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_policy>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_policy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_policy>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_policy),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_policy>())).policy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_policy),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_policy>())).policy_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_policy),
            "::",
            stringify!(policy_size)
        )
    );
}
pub type oe_policy_t = _oe_policy;
#[doc = " Blob that contains X87 and SSE data."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _oe_basic_xstate {
    #[doc = "< Holds XState i.e. X87 and SSE data"]
    pub blob: [u8; 512usize],
}
#[test]
fn bindgen_test_layout__oe_basic_xstate() {
    assert_eq!(
        ::std::mem::size_of::<_oe_basic_xstate>(),
        512usize,
        concat!("Size of: ", stringify!(_oe_basic_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_basic_xstate>(),
        16usize,
        concat!("Alignment of ", stringify!(_oe_basic_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_basic_xstate>())).blob as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_basic_xstate),
            "::",
            stringify!(blob)
        )
    );
}
pub type oe_basic_xstate_t = _oe_basic_xstate;
#[doc = " Register state to be saved before an exception and"]
#[doc = " restored after the exception has been handled in the enclave."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _oe_context {
    #[doc = " Exception flags."]
    #[doc = " OE_EXCEPTION_FLAGS_HARDWARE | OE_EXCEPTION_FLAGS_SOFTWARE"]
    pub flags: u64,
    #[doc = "< Integer register rax"]
    pub rax: u64,
    #[doc = "< Integer register rbx"]
    pub rbx: u64,
    #[doc = "< Integer register rcx"]
    pub rcx: u64,
    #[doc = "< Integer register rdx"]
    pub rdx: u64,
    #[doc = "< Integer register rbp"]
    pub rbp: u64,
    #[doc = "< Integer register rsp"]
    pub rsp: u64,
    #[doc = "< Integer register rdi"]
    pub rdi: u64,
    #[doc = "< Integer register rsi"]
    pub rsi: u64,
    #[doc = "< Integer register r8"]
    pub r8: u64,
    #[doc = "< Integer register r9"]
    pub r9: u64,
    #[doc = "< Integer register r10"]
    pub r10: u64,
    #[doc = "< Integer register r11"]
    pub r11: u64,
    #[doc = "< Integer register r12"]
    pub r12: u64,
    #[doc = "< Integer register r13"]
    pub r13: u64,
    #[doc = "< Integer register r14"]
    pub r14: u64,
    #[doc = "< Integer register r15"]
    pub r15: u64,
    #[doc = "< Integer register rip"]
    pub rip: u64,
    #[doc = "< SSE control flags"]
    pub mxcsr: u32,
    pub __bindgen_padding_0: u64,
    #[doc = "< Basic XSTATE"]
    pub basic_xstate: oe_basic_xstate_t,
}
#[test]
fn bindgen_test_layout__oe_context() {
    assert_eq!(
        ::std::mem::size_of::<_oe_context>(),
        672usize,
        concat!("Size of: ", stringify!(_oe_context))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_context>(),
        16usize,
        concat!("Alignment of ", stringify!(_oe_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rbx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rcx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rdx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rbp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rsp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rdi as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rsi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r9 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r10 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r11 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r12 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r13 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r14 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).r15 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).rip as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).mxcsr as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_context>())).basic_xstate as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_context),
            "::",
            stringify!(basic_xstate)
        )
    );
}
pub type oe_context_t = _oe_context;
#[doc = " Exception context structure with the exception code, flags, address and"]
#[doc = " calling context of the exception."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_exception_record {
    #[doc = "< Exception code"]
    pub code: u32,
    #[doc = "< Exception flags"]
    pub flags: u32,
    #[doc = "< Exception address"]
    pub address: u64,
    #[doc = "< Exception context"]
    pub context: *mut oe_context_t,
}
#[test]
fn bindgen_test_layout__oe_exception_record() {
    assert_eq!(
        ::std::mem::size_of::<_oe_exception_record>(),
        24usize,
        concat!("Size of: ", stringify!(_oe_exception_record))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_exception_record>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_exception_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_exception_record>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_exception_record),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_exception_record>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_exception_record),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_exception_record>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_exception_record),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_oe_exception_record>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_exception_record),
            "::",
            stringify!(context)
        )
    );
}
pub type oe_exception_record_t = _oe_exception_record;
#[doc = " oe_vectored_exception_handler_t - Function pointer for a vectored exception"]
#[doc = " handler in an enclave."]
#[doc = ""]
#[doc = " @param[in] exception_context The record of exception information to be"]
#[doc = " handled by the function which includes any flags, the failure code, faulting"]
#[doc = " address and calling context for the exception."]
pub type oe_vectored_exception_handler_t = ::std::option::Option<
    unsafe extern "C" fn(exception_context: *mut oe_exception_record_t) -> u64,
>;
extern "C" {
    #[doc = " Load the host file system module."]
    #[doc = ""]
    #[doc = " This function loads the host file system module"]
    #[doc = " which is needed for an enclave application to perform operations"]
    #[doc = " such as mount, fopen, fread and fwrite on files located on the host."]
    #[doc = ""]
    #[doc = " @retval OE_OK The module was successfully loaded."]
    #[doc = " @retval OE_FAILURE Module failed to load."]
    #[doc = ""]
    pub fn oe_load_module_host_file_system() -> oe_result_t;
}
extern "C" {
    #[doc = " Load the host socket interface module."]
    #[doc = ""]
    #[doc = " This function loads the host socket interface module"]
    #[doc = " which is needed for an enclave application to be able to call socket APIs"]
    #[doc = " which are routed through the host."]
    #[doc = ""]
    #[doc = " @retval OE_OK The module was successfully loaded."]
    #[doc = " @retval OE_FAILURE Module failed to load."]
    #[doc = ""]
    pub fn oe_load_module_host_socket_interface() -> oe_result_t;
}
extern "C" {
    #[doc = " Load the host resolver module."]
    #[doc = ""]
    #[doc = " This function loads the host resolver module which is needed"]
    #[doc = " for an enclave application to be able to call"]
    #[doc = " getaddrinfo and getnameinfo."]
    #[doc = ""]
    #[doc = " @retval OE_OK The module was successfully loaded."]
    #[doc = " @retval OE_FAILURE Module failed to load."]
    pub fn oe_load_module_host_resolver() -> oe_result_t;
}
extern "C" {
    #[doc = " Load the event polling (epoll) module."]
    #[doc = ""]
    #[doc = " This function loads the host epoll module which is needed"]
    #[doc = " for an enclave application to be able to call"]
    #[doc = " epoll_create1, epoll_ctl, and epoll_wait"]
    #[doc = ""]
    #[doc = " @retval OE_OK The module was successfully loaded."]
    #[doc = " @retval OE_FAILURE Module failed to load."]
    pub fn oe_load_module_host_epoll() -> oe_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_enclave_size_settings {
    pub num_heap_pages: u64,
    pub num_stack_pages: u64,
    pub num_tcs: u64,
}
#[test]
fn bindgen_test_layout__oe_enclave_size_settings() {
    assert_eq!(
        ::std::mem::size_of::<_oe_enclave_size_settings>(),
        24usize,
        concat!("Size of: ", stringify!(_oe_enclave_size_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_enclave_size_settings>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_enclave_size_settings))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_size_settings>())).num_heap_pages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_size_settings),
            "::",
            stringify!(num_heap_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_size_settings>())).num_stack_pages as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_size_settings),
            "::",
            stringify!(num_stack_pages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_size_settings>())).num_tcs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_size_settings),
            "::",
            stringify!(num_tcs)
        )
    );
}
pub type oe_enclave_size_settings_t = _oe_enclave_size_settings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_enclave_properties_header {
    #[doc = "< (0) Size of the extended structure"]
    pub size: u32,
    #[doc = "< (4) Enclave type"]
    pub enclave_type: oe_enclave_type_t,
    #[doc = "< (8) Enclave settings"]
    pub size_settings: oe_enclave_size_settings_t,
}
#[test]
fn bindgen_test_layout__oe_enclave_properties_header() {
    assert_eq!(
        ::std::mem::size_of::<_oe_enclave_properties_header>(),
        32usize,
        concat!("Size of: ", stringify!(_oe_enclave_properties_header))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_enclave_properties_header>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_enclave_properties_header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_properties_header>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_properties_header),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_properties_header>())).enclave_type as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_properties_header),
            "::",
            stringify!(enclave_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_enclave_properties_header>())).size_settings as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_enclave_properties_header),
            "::",
            stringify!(size_settings)
        )
    );
}
pub type oe_enclave_properties_header_t = _oe_enclave_properties_header;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _oe_sgx_enclave_image_info_t {
    pub oeinfo_rva: u64,
    pub oeinfo_size: u64,
    pub reloc_rva: u64,
    pub reloc_size: u64,
    pub heap_rva: u64,
    pub enclave_size: u64,
}
#[test]
fn bindgen_test_layout__oe_sgx_enclave_image_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_oe_sgx_enclave_image_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(_oe_sgx_enclave_image_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_sgx_enclave_image_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_sgx_enclave_image_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).oeinfo_rva as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(oeinfo_rva)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).oeinfo_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(oeinfo_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).reloc_rva as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(reloc_rva)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).reloc_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(reloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).heap_rva as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(heap_rva)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_image_info_t>())).enclave_size as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_image_info_t),
            "::",
            stringify!(enclave_size)
        )
    );
}
pub type oe_sgx_enclave_image_info_t = _oe_sgx_enclave_image_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oe_sgx_enclave_config_t {
    pub product_id: u16,
    pub security_version: u16,
    pub padding: u32,
    pub attributes: u64,
    pub xfrm: u64,
}
#[test]
fn bindgen_test_layout_oe_sgx_enclave_config_t() {
    assert_eq!(
        ::std::mem::size_of::<oe_sgx_enclave_config_t>(),
        24usize,
        concat!("Size of: ", stringify!(oe_sgx_enclave_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<oe_sgx_enclave_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(oe_sgx_enclave_config_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_sgx_enclave_config_t>())).product_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_sgx_enclave_config_t),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_sgx_enclave_config_t>())).security_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_sgx_enclave_config_t),
            "::",
            stringify!(security_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oe_sgx_enclave_config_t>())).padding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_sgx_enclave_config_t),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oe_sgx_enclave_config_t>())).attributes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_sgx_enclave_config_t),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oe_sgx_enclave_config_t>())).xfrm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oe_sgx_enclave_config_t),
            "::",
            stringify!(xfrm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _oe_sgx_enclave_properties {
    pub header: oe_enclave_properties_header_t,
    pub config: oe_sgx_enclave_config_t,
    pub image_info: oe_sgx_enclave_image_info_t,
    pub sigstruct: [u8; 1808usize],
    pub end_marker: u64,
}
#[test]
fn bindgen_test_layout__oe_sgx_enclave_properties() {
    assert_eq!(
        ::std::mem::size_of::<_oe_sgx_enclave_properties>(),
        1920usize,
        concat!("Size of: ", stringify!(_oe_sgx_enclave_properties))
    );
    assert_eq!(
        ::std::mem::align_of::<_oe_sgx_enclave_properties>(),
        8usize,
        concat!("Alignment of ", stringify!(_oe_sgx_enclave_properties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_properties>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_properties),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_properties>())).config as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_properties),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_properties>())).image_info as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_properties),
            "::",
            stringify!(image_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_properties>())).sigstruct as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_properties),
            "::",
            stringify!(sigstruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_oe_sgx_enclave_properties>())).end_marker as *const _ as usize
        },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(_oe_sgx_enclave_properties),
            "::",
            stringify!(end_marker)
        )
    );
}
pub type oe_sgx_enclave_properties_t = _oe_sgx_enclave_properties;
extern "C" {
    #[doc = " This function sets the minimum value of issue dates of CRL and TCB info"]
    #[doc = " accepted by the enclave. CRL and TCB info issued before this date"]
    #[doc = " are rejected for attestation."]
    #[doc = " This function is not thread safe."]
    #[doc = " Results of calling this function multiple times from within an enclave"]
    #[doc = " are undefined."]
    pub fn __oe_sgx_set_minimum_crl_tcb_issue_date(
        year: u32,
        month: u32,
        day: u32,
        hours: u32,
        minutes: u32,
        seconds: u32,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Register a new vectored exception handler."]
    #[doc = ""]
    #[doc = " Call this function to add a new vectored exception handler. If successful,"]
    #[doc = " the registered handler will be called when an exception happens inside the"]
    #[doc = " enclave."]
    #[doc = ""]
    #[doc = " @param[in] is_first_handler The parameter indicates that the input handler"]
    #[doc = " should be the first exception handler to be called. If it is false, the input"]
    #[doc = " handler will be appended to the end of exception handler chain, otherwise"]
    #[doc = " it will be added as the first handler in the exception handler chain."]
    #[doc = " @param[in] vectored_handler The input vectored exception handler to register."]
    #[doc = " It must be a function defined in the enclave. The same handler can only be"]
    #[doc = " registered once; a 2nd registration will fail. If the function succeeds, the"]
    #[doc = " handler may be removed later by passing it to"]
    #[doc = " oe_remove_vectored_exception_handler()."]
    #[doc = ""]
    #[doc = " @returns OE_OK successful"]
    #[doc = " @returns OE_INVALID_PARAMETER a parameter is invalid"]
    #[doc = " @returns OE_FAILURE failed to add handler"]
    pub fn oe_add_vectored_exception_handler(
        is_first_handler: bool,
        vectored_handler: oe_vectored_exception_handler_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Remove an existing vectored exception handler."]
    #[doc = ""]
    #[doc = " @param[in] vectored_handler The pointer to a registered exception handler"]
    #[doc = " returned from a successful oe_add_vectored_exception_handler() call."]
    #[doc = ""]
    #[doc = " @returns OE_OK success"]
    #[doc = " @returns OE_INVALID_PARAMETER a parameter is invalid"]
    #[doc = " @returns OE_FAILURE failed to remove handler"]
    pub fn oe_remove_vectored_exception_handler(
        vectored_handler: oe_vectored_exception_handler_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Check whether the given buffer is strictly within the enclave."]
    #[doc = ""]
    #[doc = " Check whether the buffer given by the **ptr** and **size** parameters is"]
    #[doc = " strictly within the enclave's memory. If so, return true. If any"]
    #[doc = " portion of the buffer lies outside the enclave's memory, return false."]
    #[doc = ""]
    #[doc = " @param[in] ptr The pointer pointer to buffer."]
    #[doc = " @param[in] size The size of buffer"]
    #[doc = ""]
    #[doc = " @retval true The buffer is strictly within the enclave."]
    #[doc = " @retval false At least some part of the buffer is outside the enclave, or"]
    #[doc = " the arguments are invalid. For example, if **ptr** is null or **size**"]
    #[doc = " causes arithmetic operations to wrap."]
    #[doc = ""]
    pub fn oe_is_within_enclave(ptr: *const ::std::os::raw::c_void, size: size_t) -> bool;
}
extern "C" {
    #[doc = " Check whether the given buffer is strictly outside the enclave."]
    #[doc = ""]
    #[doc = " Check whether the buffer given by the **ptr** and **size** parameters is"]
    #[doc = " strictly outside the enclave's memory. If so, return true. If any"]
    #[doc = " portion of the buffer lies within the enclave's memory, return false."]
    #[doc = ""]
    #[doc = " @param[in] ptr The pointer to buffer."]
    #[doc = " @param[in] size The size of buffer."]
    #[doc = ""]
    #[doc = " @retval true The buffer is strictly outside the enclave."]
    #[doc = " @retval false At least some part of the buffer is inside the enclave, or"]
    #[doc = " the arguments are invalid. For example, if **ptr** is null or **size**"]
    #[doc = " causes arithmetic operations to wrap."]
    #[doc = ""]
    pub fn oe_is_outside_enclave(ptr: *const ::std::os::raw::c_void, size: size_t) -> bool;
}
extern "C" {
    #[doc = " Allocate bytes from the host's heap."]
    #[doc = ""]
    #[doc = " This function allocates **size** bytes from the host's heap and returns the"]
    #[doc = " address of the allocated memory. The implementation performs an OCALL to"]
    #[doc = " the host, which calls malloc(). To free the memory, it must be passed to"]
    #[doc = " oe_host_free()."]
    #[doc = ""]
    #[doc = " @param[in] size The number of bytes to be allocated."]
    #[doc = ""]
    #[doc = " @returns The allocated memory or NULL if unable to allocate the memory."]
    #[doc = ""]
    pub fn oe_host_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reallocate bytes from the host's heap."]
    #[doc = ""]
    #[doc = " This function changes the size of the memory block pointed to by **ptr**"]
    #[doc = " on the host's heap to **size** bytes. The memory block may be moved to a"]
    #[doc = " new location, which is returned by this function. The implementation"]
    #[doc = " performs an OCALL to the host, which calls realloc(). To free the memory,"]
    #[doc = " it must be passed to oe_host_free()."]
    #[doc = ""]
    #[doc = " @param[in] ptr The memory block to change the size of. If NULL, this method"]
    #[doc = " allocates **size** bytes as if oe_host_malloc was invoked. If not NULL,"]
    #[doc = " it should be a pointer returned by a previous call to oe_host_calloc,"]
    #[doc = " oe_host_malloc or oe_host_realloc."]
    #[doc = " @param[in] size The number of bytes to be allocated. If 0, this method"]
    #[doc = " deallocates the memory at **ptr**. If the new size is larger, the value"]
    #[doc = " of the memory in the new allocated range is indeterminate."]
    #[doc = ""]
    #[doc = " @returns The pointer to the reallocated memory or NULL if **ptr** was"]
    #[doc = " freed by setting **size** to 0. This method also returns NULL if it was"]
    #[doc = " unable to reallocate the memory, in which case the original **ptr**"]
    #[doc = " remains valid and its contents are unchanged."]
    #[doc = ""]
    pub fn oe_host_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate zero-filled bytes from the host's heap."]
    #[doc = ""]
    #[doc = " This function allocates **size** bytes from the host's heap and fills it"]
    #[doc = " with zero character. It returns the address of the allocated memory. The"]
    #[doc = " implementation performs an OCALL to the host, which calls calloc()."]
    #[doc = " To free the memory, it must be passed to oe_host_free()."]
    #[doc = ""]
    #[doc = " @param[in] nmemb The number of elements to be allocated and zero-filled."]
    #[doc = " @param[in] size The size of each element."]
    #[doc = ""]
    #[doc = " @returns The allocated memory or NULL if unable to allocate the memory."]
    #[doc = ""]
    pub fn oe_host_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Release allocated memory."]
    #[doc = ""]
    #[doc = " This function releases memory allocated with oe_host_malloc() or"]
    #[doc = " oe_host_calloc() by performing an OCALL where the host calls free()."]
    #[doc = ""]
    #[doc = " @param[in] ptr Pointer to memory to be released or null."]
    #[doc = ""]
    pub fn oe_host_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Make a heap copy of a string."]
    #[doc = ""]
    #[doc = " This function allocates memory on the host's heap, copies no more than"]
    #[doc = " *n* bytes from the **str** parameter to that memory, and returns a pointer"]
    #[doc = " to the newly allocated memory."]
    #[doc = ""]
    #[doc = " @param[in] str The string to be copied."]
    #[doc = " @param[in] n The number of characters to be copied."]
    #[doc = ""]
    #[doc = " @returns A pointer to the newly allocated string or NULL if unable to"]
    #[doc = " allocate the storage."]
    #[doc = ""]
    pub fn oe_host_strndup(
        str: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Abort execution of the enclave."]
    #[doc = ""]
    #[doc = " Mark the enclave as aborting. This blocks future enclave entry calls. The"]
    #[doc = " enclave continues to execute until all threads exit the enclave."]
    pub fn oe_abort();
}
extern "C" {
    #[doc = " Called whenever an assertion fails."]
    #[doc = ""]
    #[doc = " This internal function is called when the expression of the oe_assert()"]
    #[doc = " macro evaluates to zero. For example:"]
    #[doc = ""]
    #[doc = "     oe_assert(x > y);"]
    #[doc = ""]
    #[doc = " If the expression evaluates to zero, this function is called with the"]
    #[doc = " string representation of the expression as well as the file, the line, and"]
    #[doc = " the function name where the macro was expanded."]
    #[doc = ""]
    #[doc = " The __oe_assert_fail() function performs a host call to print a message"]
    #[doc = " and then calls oe_abort()."]
    #[doc = ""]
    #[doc = " @param[in] expr The argument of the oe_assert() macro."]
    #[doc = " @param[in] file The name of the file where oe_assert() was invoked."]
    #[doc = " @param[in] line The line number where oe_assert() was invoked."]
    #[doc = " @param[in] func The name of the function that invoked oe_assert()."]
    #[doc = ""]
    pub fn __oe_assert_fail(
        expr: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get a report signed by the enclave platform for use in attestation."]
    #[doc = ""]
    #[doc = " This function creates a report to be used in local or remote attestation. The"]
    #[doc = " report shall contain the data given by the **report_data** parameter."]
    #[doc = ""]
    #[doc = " @param[in] flags Specifying default value (0) generates a report for local"]
    #[doc = " attestation. Specifying OE_REPORT_FLAGS_REMOTE_ATTESTATION generates a"]
    #[doc = " report for remote attestation."]
    #[doc = " @param[in] report_data The report data that will be included in the report."]
    #[doc = " @param[in] report_data_size The size of the **report_data** in bytes."]
    #[doc = " @param[in] opt_params Optional additional parameters needed for the current"]
    #[doc = " enclave type. For SGX, this can be sgx_target_info_t for local attestation."]
    #[doc = " @param[in] opt_params_size The size of the **opt_params** buffer."]
    #[doc = " @param[out] report_buffer This points to the resulting report upon success."]
    #[doc = " @param[out] report_buffer_size This is set to the"]
    #[doc = " size of the report buffer on success."]
    #[doc = ""]
    #[doc = " @retval OE_OK The report was successfully created."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_OUT_OF_MEMORY Failed to allocate memory."]
    #[doc = ""]
    pub fn oe_get_report_v2(
        flags: u32,
        report_data: *const u8,
        report_data_size: size_t,
        opt_params: *const ::std::os::raw::c_void,
        opt_params_size: size_t,
        report_buffer: *mut *mut u8,
        report_buffer_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Frees a report buffer obtained from oe_get_report."]
    #[doc = ""]
    #[doc = " @param[in] report_buffer The report buffer to free."]
    pub fn oe_free_report(report_buffer: *mut u8);
}
extern "C" {
    #[doc = " Extracts additional platform specific data from the report and writes"]
    #[doc = " it to *target_info_buffer*. After calling this function, the"]
    #[doc = " *target_info_buffer* can used for the *opt_params* field in *oe_get_report*."]
    #[doc = ""]
    #[doc = " For example, on SGX, the *target_info_buffer* can be used as a"]
    #[doc = " sgx_target_info_t for local attestation."]
    #[doc = ""]
    #[doc = " @param[in] report The report returned by **oe_get_report**."]
    #[doc = " @param[in] report_size The size of **report** in bytes."]
    #[doc = " @param[out] target_info_buffer This points to the platform specific data"]
    #[doc = " upon success."]
    #[doc = " @param[out] target_info_size This is set to"]
    #[doc = " the size of **target_info_buffer** on success."]
    #[doc = ""]
    #[doc = " @retval OE_OK The platform specific data was successfully extracted."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_OUT_OF_MEMORY Failed to allocate memory."]
    #[doc = ""]
    pub fn oe_get_target_info_v2(
        report: *const u8,
        report_size: size_t,
        target_info_buffer: *mut *mut ::std::os::raw::c_void,
        target_info_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Frees target info obtained from oe_get_target_info."]
    #[doc = ""]
    #[doc = " @param[in] target_info The platform specific data to free."]
    #[doc = ""]
    pub fn oe_free_target_info(target_info: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Parse an enclave report into a standard format for reading."]
    #[doc = ""]
    #[doc = " @param[in] report The buffer containing the report to parse."]
    #[doc = " @param[in] report_size The size of the **report** buffer."]
    #[doc = " @param[out] parsed_report The **oe_report_t** structure to populate with the"]
    #[doc = " report"]
    #[doc = " properties in a standard format. The *parsed_report* holds pointers to fields"]
    #[doc = " within the supplied *report* and must not be used beyond the lifetime of the"]
    #[doc = " *report*."]
    #[doc = ""]
    #[doc = " @retval OE_OK The report was successfully created."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = ""]
    pub fn oe_parse_report(
        report: *const u8,
        report_size: size_t,
        parsed_report: *mut oe_report_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Verify the integrity of the report and its signature."]
    #[doc = ""]
    #[doc = " This function verifies that the report signature is valid. If the report is"]
    #[doc = " local, it verifies that it is correctly signed by the enclave"]
    #[doc = " platform. If the report is remote, it verifies that the signing authority is"]
    #[doc = " rooted to a trusted authority such as the enclave platform manufacturer."]
    #[doc = ""]
    #[doc = " @param[in] report The buffer containing the report to verify."]
    #[doc = " @param[in] report_size The size of the **report** buffer."]
    #[doc = " @param[out] parsed_report Optional **oe_report_t** structure to populate with"]
    #[doc = " the report properties in a standard format."]
    #[doc = ""]
    #[doc = " @retval OE_OK The report was successfully created."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = ""]
    pub fn oe_verify_report(
        report: *const u8,
        report_size: size_t,
        parsed_report: *mut oe_report_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Get a symmetric encryption key derived from the specified policy and coupled"]
    #[doc = " to the enclave platform."]
    #[doc = ""]
    #[doc = " @param[in] seal_policy The policy for the identity properties used to derive"]
    #[doc = " the"]
    #[doc = " seal key."]
    #[doc = " @param[out] key_buffer This contains the resulting seal key upon success."]
    #[doc = " Freed by calling oe_free_key()."]
    #[doc = " @param[out] key_buffer_size This contains the size of the **key_buffer**"]
    #[doc = " buffer upon success."]
    #[doc = " @param[out] key_info If non-NULL, then on success this points to the"]
    #[doc = " enclave-specific key information which"]
    #[doc = " can be used to retrieve the same key later, on a newer security version."]
    #[doc = " Freed by calling oe_free_key()."]
    #[doc = " @param[out] key_info_size On success, this is the size of the **key_info**"]
    #[doc = " buffer."]
    #[doc = ""]
    #[doc = " @retval OE_OK The seal key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_UNEXPECTED An unexpected error happened."]
    #[doc = " @retval OE_OUT_OF_MEMORY Failed to allocate memory."]
    pub fn oe_get_seal_key_by_policy_v2(
        seal_policy: oe_seal_policy_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
        key_info: *mut *mut u8,
        key_info_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Returns a public key that is associated with the identity of the enclave"]
    #[doc = " and the specified policy."]
    #[doc = ""]
    #[doc = " @param[in] seal_policy The policy for the identity properties used to derive"]
    #[doc = " the key."]
    #[doc = " @param[in] key_params The parameters for the asymmetric key derivation."]
    #[doc = " @param[out] key_buffer A pointer to the buffer that on success contains the"]
    #[doc = " requested public key."]
    #[doc = " @param[out] key_buffer_size On success, this contains size of key_buffer."]
    #[doc = " @param[out] key_info Optional pointer to a buffer for the enclave-specific"]
    #[doc = " key information which can be used to retrieve the same key later on a newer"]
    #[doc = " security version."]
    #[doc = " @param[out] key_info_size On success, this contains the size of key_info."]
    #[doc = ""]
    #[doc = " @retval OE_OK The key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_OUT_OF_MEMORY There is no memory available."]
    #[doc = " @retval OE_UNEXPECTED An unexpected error happened."]
    pub fn oe_get_public_key_by_policy(
        seal_policy: oe_seal_policy_t,
        key_params: *const oe_asymmetric_key_params_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
        key_info: *mut *mut u8,
        key_info_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Returns a public key that is associated with the identity of the enclave."]
    #[doc = ""]
    #[doc = " @param[in] key_params The parameters for the asymmetric key derivation."]
    #[doc = " @param[in] key_info The enclave-specific key information to derive the key."]
    #[doc = " @param[in] key_info_size The size of the key_info buffer."]
    #[doc = " @param[out] key_buffer A pointer to the buffer that on success contains the"]
    #[doc = " requested public key."]
    #[doc = " @param[out] key_buffer_size On success, this contains size of key_buffer."]
    #[doc = ""]
    #[doc = " @retval OE_OK The key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_INVALID_CPUSVN The platform specific data has an invalid CPUSVN."]
    #[doc = " @retval OE_INVALID_ISVSVN The platform specific data has an invalid ISVSVN."]
    #[doc = " @retval OE_INVALID_KEYNAME The platform specific data has an invalid KEYNAME."]
    pub fn oe_get_public_key(
        key_params: *const oe_asymmetric_key_params_t,
        key_info: *const u8,
        key_info_size: size_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Returns a private key that is associated with the identity of the enclave"]
    #[doc = " and the specified policy."]
    #[doc = ""]
    #[doc = " @param[in] seal_policy The policy for the identity properties used to derive"]
    #[doc = " the asymmetric key."]
    #[doc = " @param[in] key_params The parameters for the asymmetric key derivation."]
    #[doc = " @param[out] key_buffer A pointer to the buffer that on success contains the"]
    #[doc = " requested private key."]
    #[doc = " @param[out] key_buffer_size On success, this contains size of key_buffer."]
    #[doc = " @param[out] key_info Optional pointer to a buffer for the enclave-specific"]
    #[doc = " key information which can be used to retrieve the same key later on a newer"]
    #[doc = " security version."]
    #[doc = " @param[out] key_info_size On success, this contains the size of key_info."]
    #[doc = ""]
    #[doc = " @retval OE_OK The key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_OUT_OF_MEMORY There is no memory available."]
    #[doc = " @retval OE_UNEXPECTED An unexpected error happened."]
    pub fn oe_get_private_key_by_policy(
        seal_policy: oe_seal_policy_t,
        key_params: *const oe_asymmetric_key_params_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
        key_info: *mut *mut u8,
        key_info_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Returns a private key that is associated with the identity of the enclave."]
    #[doc = ""]
    #[doc = " @param[in] key_params The parameters for the asymmetric key derivation."]
    #[doc = " @param[in] key_info The enclave-specific key information to derive the key."]
    #[doc = " @param[in] key_info_size The size of the key_info buffer."]
    #[doc = " @param[out] key_buffer A pointer to the buffer that on success contains the"]
    #[doc = " requested private key."]
    #[doc = " @param[out] key_buffer_size On success, this contains size of key_buffer."]
    #[doc = ""]
    #[doc = " @retval OE_OK The key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_INVALID_CPUSVN The platform specific data has an invalid CPUSVN."]
    #[doc = " @retval OE_INVALID_ISVSVN The platform specific data has an invalid ISVSVN."]
    #[doc = " @retval OE_INVALID_KEYNAME The platform specific data has an invalid KEYNAME."]
    pub fn oe_get_private_key(
        key_params: *const oe_asymmetric_key_params_t,
        key_info: *const u8,
        key_info_size: size_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Frees the given key and/or key info. Before freeing, this function will"]
    #[doc = " zero out the key buffers to avoid leaking any confidential data.."]
    #[doc = ""]
    #[doc = " @param[in] key_buffer If not NULL, the key buffer to free."]
    #[doc = " @param[in] key_buffer_size The size of key_buffer."]
    #[doc = " @param[in] key_info If not NULL, the key info to free."]
    #[doc = " @param[in] key_info_size The size of key_info."]
    pub fn oe_free_key(
        key_buffer: *mut u8,
        key_buffer_size: size_t,
        key_info: *mut u8,
        key_info_size: size_t,
    );
}
extern "C" {
    #[doc = " Get a symmetric encryption key from the enclave platform using existing key"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " @param[in] key_info The enclave-specific key information to derive the seal"]
    #[doc = " key with."]
    #[doc = " @param[in] key_info_size The size of the **key_info** buffer."]
    #[doc = " @param[out] key_buffer Upon success, this points to the resulting seal key,"]
    #[doc = " which should be freed with oe_free_key()."]
    #[doc = " @param[out] key_buffer_size Upon success, this contains the size of the"]
    #[doc = " **key_buffer** buffer, which should be freed with oe_free_key()."]
    #[doc = ""]
    #[doc = " @retval OE_OK The seal key was successfully requested."]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid."]
    #[doc = " @retval OE_INVALID_CPUSVN **key_info** contains an invalid CPUSVN."]
    #[doc = " @retval OE_INVALID_ISVSVN **key_info** contains an invalid ISVSVN."]
    #[doc = " @retval OE_INVALID_KEYNAME **key_info** contains an invalid KEYNAME."]
    #[doc = " @retval OE_OUT_OF_MEMORY Failed to allocate memory."]
    pub fn oe_get_seal_key_v2(
        key_info: *const u8,
        key_info_size: size_t,
        key_buffer: *mut *mut u8,
        key_buffer_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Frees a key and/or key info."]
    #[doc = ""]
    #[doc = " @param[in] key_buffer If non-NULL, the key buffer to free."]
    #[doc = " @param[in] key_info If non-NULL, the key info buffer to free."]
    pub fn oe_free_seal_key(key_buffer: *mut u8, key_info: *mut u8);
}
extern "C" {
    #[doc = " Obtains the enclave handle."]
    #[doc = ""]
    #[doc = " This function returns the enclave handle for the current enclave. The"]
    #[doc = " host obtains this handle by calling **oe_create_enclave()**, which"]
    #[doc = " passes the enclave handle to the enclave during initialization. The"]
    #[doc = " handle is an address inside the host address space. This pointer is opaque"]
    #[doc = " and is never dereferenced within the enclave. The corresponding structure"]
    #[doc = " definition (struct _oe_enclave) is not visible from any enclave headers."]
    #[doc = ""]
    #[doc = " @returns the enclave handle."]
    pub fn oe_get_enclave() -> *mut oe_enclave_t;
}
extern "C" {
    #[doc = " Generate a sequence of random bytes."]
    #[doc = ""]
    #[doc = " This function generates a sequence of random bytes."]
    #[doc = ""]
    #[doc = " @param[out] data the buffer that will be filled with random bytes"]
    #[doc = " @param[in] size the size of the buffer"]
    #[doc = ""]
    #[doc = " @return OE_OK on success"]
    pub fn oe_random(data: *mut ::std::os::raw::c_void, size: size_t) -> oe_result_t;
}
extern "C" {
    #[doc = " oe_generate_attestation_certificate."]
    #[doc = ""]
    #[doc = " This function generates a self-signed x.509 certificate with an embedded"]
    #[doc = " quote from the underlying enclave."]
    #[doc = ""]
    #[doc = " @param[in] subject_name a string contains an X.509 distinguished"]
    #[doc = " name (DN) for customizing the generated certificate. This name is also used"]
    #[doc = " as the issuer name because this is a self-signed certificate"]
    #[doc = " See RFC5280 (https://tools.ietf.org/html/rfc5280) specification for details"]
    #[doc = " Example value \"CN=Open Enclave SDK,O=OESDK TLS,C=US\""]
    #[doc = ""]
    #[doc = " @param[in] private_key a private key used to sign this certificate"]
    #[doc = " @param[in] private_key_size The size of the private_key buffer"]
    #[doc = " @param[in] public_key a public key used as the certificate's subject key"]
    #[doc = " @param[in] public_key_size The size of the public_key buffer."]
    #[doc = ""]
    #[doc = " @param[out] output_cert a pointer to buffer pointer"]
    #[doc = " @param[out] output_cert_size size of the buffer above"]
    #[doc = ""]
    #[doc = " @return OE_OK on success"]
    pub fn oe_generate_attestation_certificate(
        subject_name: *const ::std::os::raw::c_uchar,
        private_key: *mut u8,
        private_key_size: size_t,
        public_key: *mut u8,
        public_key_size: size_t,
        output_cert: *mut *mut u8,
        output_cert_size: *mut size_t,
    ) -> oe_result_t;
}
extern "C" {
    #[doc = " Free the given cert"]
    #[doc = " @param[in] cert If not NULL, the buffer to free."]
    pub fn oe_free_attestation_certificate(cert: *mut u8);
}
#[doc = " identity validation callback type"]
#[doc = " @param[in] identity a pointer to an enclave's identity information"]
#[doc = " @param[in] arg caller defined context"]
pub type oe_identity_verify_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        identity: *mut oe_identity_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> oe_result_t,
>;
extern "C" {
    #[doc = " oe_verify_attestation_certificate"]
    #[doc = ""]
    #[doc = " This function perform a custom validation on the input certificate. This"]
    #[doc = " validation includes extracting an attestation evidence extension from the"]
    #[doc = " certificate before validating this evidence. An optional"]
    #[doc = " enclave_identity_callback could be passed in for a calling client to further"]
    #[doc = " validate the identity of the enclave creating the quote."]
    #[doc = " OE_FAILURE is returned if the expected certificate extension OID is not"]
    #[doc = " found."]
    #[doc = " @param[in] cert_in_der a pointer to buffer holding certificate contents"]
    #[doc = "  in DER format"]
    #[doc = " @param[in] cert_in_der_len size of certificate buffer above"]
    #[doc = " @param[in] enclave_identity_callback callback routine for custom identity"]
    #[doc = " checking"]
    #[doc = " @param[in] arg an optional context pointer argument specified by the caller"]
    #[doc = " when setting callback"]
    #[doc = " @retval OE_OK on a successful validation"]
    #[doc = " @retval OE_VERIFY_FAILED on quote failure"]
    #[doc = " @retval OE_INVALID_PARAMETER At least one parameter is invalid"]
    #[doc = " @retval OE_FAILURE general failure"]
    #[doc = " @retval other appropriate error code"]
    pub fn oe_verify_attestation_certificate(
        cert_in_der: *mut u8,
        cert_in_der_len: size_t,
        enclave_identity_callback: oe_identity_verify_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> oe_result_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
